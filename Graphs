#include<stdio.h>  
#define MAX 10  
typedef struct Q  
{  
int R,F;  
int data[MAX];  
}Q;  
int empty (Q *P);  
int full(Q *P);  
void enqueue(Q *P,int x);  
int dequeue(Q *P);  
void BFS(int);  
void DFS(int);  
int G[MAX][MAX];  
int n=0;  
int visited[MAX];  
int main()  
{  
int i,j,v,op,nedges;  
printf("\n Enter no of vertices : ");  
scanf("%d",&n);  
printf("\nEnter the no of edges : ");  
scanf("%d",&nedges);  
for(i=0;i<n;i++)  
for(j=0;j<n;j++)  
G[i][j] =0;  
printf("\nEnter the Graph as list of edges( Starting vertex No is 0");  
for(v=0;v<nedges;v++)  
{  
printf("\nEnter the next edge(Start vertex, end vertex);");  
scanf("%d%d", &i,&j);  
G[i][j] = G[j][i]= 1;  
}  
do{  
printf("\n\n1. DFS\n2. BFS\n3. Display the graph\n 4. Exit");  
printf("\nEnter your choice");  
scanf("%d",&op);  
switch(op)  
{  
case 1:  printf("\nEnter the starting vertex for DFS");  
scanf("%d",&v);  
for(i=0;i<n;i++)  
visited[i] = 0;  
DFS(v);  
break;  
case 2:  printf("Enter the starting vertex for BFS");  
    scanf("%d",&v);  
    BFS(v);  
    break;  
  case 3:  printf("Adjacency Matrix : \n");  
    for(i=0;i<n;i++)  
    {  
     printf("\n");  
     for(j=0;j<n;j++)  
          printf("%d\t",G[i][j]);  
     }  
    break;  
      }  
   }while(op!= 4);  
   return 0;  
  }  
  
   void BFS(int v)  
   {  
    int i;  
    Q q;  
    q.R=-1;  
    q.F=0;  
    for(i=0;i<n;i++)  
    visited[i] = 0;  
    enqueue(&q,v);  
    printf("\n visit :\n%d",v);  
    visited[v]=1;  
    while(!empty(&q))  
       {  
    v= dequeue(&q);  
    for(i=0;i<n;i++)  
       if (visited[i] ==0 && G[v][i]!= 0)  
    { enqueue(&q,i);  
     visited[i] = 1;  
     printf("\n%d",i);  
    }  
        }  
    }  
  
    int empty(Q *P)  
    {  
   if(P->F== P->R+1)  
    return 1;  
   else  
    return 0;  
     }  
  
     int full(Q *P)  
     {  
   if(P-> R == MAX-1)  
    return 1;  
   else  
    return 0;  
     }  
       
     void enqueue(Q *P, int x)  
     {  
   if (full(P)==1)  
   {  
    printf("Queue is full");     
   }  
   else  
   {  P->R=P->R+1;  
    P->data[P->R]= x;  
   }  
     }  
  
     int dequeue(Q *P)  
     {  
   int x;  
    x=P->data[P->F];  
    if(empty(P)==1)  
     {  
       P->R= -1;  
       P->F= 0;  
     }  
     else  
      P->F=P->F+1;  
      return(x);  
     }  
  
void DFS(int i)  
{  int j;  
printf("\n%d", i);  
visited[i] =1;  
for(j=0;j<n;j++)  
if(!visited[j] && G[i][j] ==1)  
DFS(j);  
}  
